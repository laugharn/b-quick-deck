# b quick

### You don't have to deal with ~~the dealers~~ complexity, let your ~~boyfriend~~ toolchain deal with ~~the dealers~~ complexity.

January 15, 2019
---
## Tools Discussed

* Yarn Workspaces
* Next.js
* React Hooks
* Tailwind
* purgeCSS
* Zeit Now
---
## Yarn Workspaces

### JavaScript monorepos made easy...er.

https://yarnpkg.com/lang/en/docs/workspaces/
---
## Why Yarn?

* Workspaces make local development easy
* Faster than NPM
* Works well with Lerna
* `yarn dev` instead of `npm run dev` saves me four characters
---
## Why Not Yarn?

* No individual package lock files
* Accidentally running npm out of habit
* Yarn global isn't reliable compared to NPM
* Do you trust Facebook?
---
## Next.js

### A React framework that Just Works

https://nextjs.org
---
## Why Next.js

* The universe arcs towards frameworks
* Server-side Rendering (SSR)
* Sensible but extensible Webpack, Babel, etc.
* Dynamic or static output
* Robust ecosystem
* Lambda optimized
* Big boy validated (Hulu, Netflix, Walmart, Tencent)
---
## Why Not Next.js

* You don't like frameworks
* No need for SSR
* Dynamic routing is tricky
* Files like _app.js and _document.js are still a little magical
* Your local dev and production dev will likely not be 1:1
---
## Next.js Demos

* Pages
* next.config.js
* With Express
---
## Pages
---
## next.config.js
---
## With Express
---
## React Hooks

### Imagine the Drake meme and he doesn't like classes but he does like functions

https://reactjs.org/docs/hooks-intro.html
---
## Why React Hooks?

* Functional components can behave statefully
* Code is much easier to read
* State functionality can easily be shared
* Effects can be bound more explicitly
* Can be implemented incrementally
---
## Why Not React Hooks?

* Easy to be used improperly
* Writing effects for event emitters can be awkward
---
## React Hooks Demos

* useState
* useReducer
* useEffect
* Final Form
---
## useState

### Get reactive, stateful values without classes

```js
export default () => {
    const [count, setCount] = useState(0)

    return <button onClick={e => setCount(count + 1)}>{count}</button>
}
```
---
## useReducer

### If you love Redux for some reason

```js
const counterReducer = (state, action) => {
    // Imagine a reducer here
}

export default ()=> {
    const [state, dispatch] = useReducer(counterReducer, 0)

    // Imagine buttons that dispatch actions
}
```
---
## useEffect
---
## Final Form

### How third parties are using hooks

```js
export default () => {
    const { form, handleSubmit, pristine, submitting, values } = useForm({
        onSubmit, // A submit function
        validate // A validator
    })

    const firstName = useField('username', form)
    const lastName = useField('password', form)

    // Imagine a form
}
```
---
## Tailwind

### Configuration-based utility classes

https://tailwindcss.com
---
## Why Tailwind?

* Utility classes are easy to understand and write
* BEM fails/gets too complex without orthodoxy
* CSS-in-JS is difficult to share/handle states
* Active community with a full-time maintainer
---
## Why not Tailwind?

* Global, not component-based solution
* Without a build process, can result in a very large library
* @apply doesn't work as well as you want it to
---
## purgeCSS

### Marie Kondo for your stylesheets

https://www.purgecss.com/
---
## Why purgeCSS?

* What treeshaking does for JavaScript, purgeCSS does for CSS
* Don't worry about how big your library is
---
## Why not purgeCSS?

* Requires writing configuration
* Configuration can get complicated with dynamic class values
---
## Zeit Now

### Lambdas made easy

https://zeit.co/now
---
## Why Zeit Now?
---
## Why Not Zeit Now?
---
## Thanks

* https://github.com/laugharn/b-quick
* https://github.com/laugharn/b-quick-deck